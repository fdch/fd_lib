/*

	freeverb~


	Tilde object that implements the Schroeder/Moorer reverb model.

	Written by Olaf Matthes <laf.matthes@gmx.de>.  

	This program is free software; you can redistribute it and/or modify it 
	under the terms of the GNU General Public License as published by the
	Free Software Foundation; either version 2 of the License,
	or (at your option) any later version. 

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of 
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
	GNU General Public License for more details.

	You should have received a copy of the 
	GNU General Public License along with this program; 
	if not, write to:

	Free Software Foundation, Inc., 
	59 Temple Place - Suite 330, 
	Boston, MA  02111-1307, USA.  
*/
#include "m_pd.h"
#include <math.h>
#include <string.h>

#define version "freeverb~ v1.2.2"

#define LOGTEN 2.302585092994

#define	numcombs		8
#define	nallpass		4
#define	muted			0
#define	fixedgain		0.015
#define scalewet		3.0
#define scaledry		2.0
#define scaledamp		0.4
#define scaleroom		0.28
#define offsetroom		0.7
#define initialroom		0.5
#define initialdamp		0.5
#define initialwet		1.0/scalewet
#define initialdry		0.0
#define initialwidth	1.0
#define initialmode		0
#define initialbypass   0
#define freezemode		0.5
#define	stereospread	23

/* 
	these values assume 44.1KHz sample rate
	they will probably be OK for 48KHz sample rate
	but would need scaling for 96KHz (or other) sample rates.
	the values were obtained by listening tests.                
*/




// static const int combtuningL[numcombs]
//                      = {1116, 1188, 
//                      	1277, 1356,
//                      	1422, 1491,
//                      	1557, 1617
//                      	};
// static const int combtuningR[numcombs]
//                      = {1116+stereospread, 1188+stereospread, 
//                      	1277+stereospread, 1356+stereospread,
// 					    1422+stereospread, 1491+stereospread, 
// 					    1557+stereospread, 1617+stereospread 
// 					  	};

// static const int allpasstuningL[numallpasses]
//                      = {556, 441, 
//                      	341, 225
//                      	};
// static const int allpasstuningR[numallpasses]
//                      = {556+stereospread, 441+stereospread,
//                      	341+stereospread, 225+stereospread
//                      	};


static t_class *freeverb_class;

typedef struct _freeverb
{
    t_object x_obj;
    t_symbol *x_objsym;
	/* freeverb stuff */
	t_float	x_gain;
	t_float	x_roomsize,x_roomsize1;
	t_float	x_damp,x_damp1;
	t_float	x_wet,x_wet1,x_wet2;
	t_float	x_dry;
	t_float	x_width;
	t_float	x_mode;
	t_float x_bypass;
	t_int   x_skip;

	t_int x_spread;
	/* We make numcoms and allpasses dynamic instead of a macro */
	t_int 	x_numcombs, x_nallpass;

	t_float	x_allpassfeedback;	/* feedback of allpass filters */
	t_float	x_combfeedback;		/* feedback of comb filters */
	t_float x_combdamp1, x_combdamp2;
	
	/* stores last sample value */
	t_float *x_filterstoreL, *x_filterstoreR;

	
	t_float	*x_bufcombL, *x_bufcombR;			/* delay lines */
	t_float	*x_bufallpassL, *x_bufallpassR;		/* delay lines */
	
	t_int 	*x_allpassidxL, *x_allpassidxR;
	t_int 	*x_combidxL, *x_combidxR;

	
	/* Flags for default allpass or combfil*/
	t_int x_default_allpass, x_default_combfil;

	t_symbol *x_combarrayName, *x_allparrayName;

	/* local copies adjusted to fit our sample rate */
	t_word 	*x_combvec, *x_allpvec; 	/* the actual arrays */
	t_int 	x_combarrayPoints, x_allparrayPoints;
	t_int 	*x_combtuningL, *x_combtuningR;
	t_int 	*x_allpasstuningL, *x_allpasstuningR;

	t_float x_float;
	
	/*	Original comb filter values */
	t_int oCombVals[numcombs];
	/*	Original all pass filter values */
	t_int oAllPVals[nallpass];
} t_freeverb;




	// // recalculate the reverb parameters in case we don't run at 44.1kHz
	// for(i = 0; i < x->x_numcombs; i++)
	// {
	// 	x->x_combtuningL[i] = (int)(combtuningL[i] * sr / 44100);
	// 	x->x_combtuningR[i] = (int)(combtuningR[i] * sr / 44100);
	// }
	// for(i = 0; i < x->x_nallpass; i++)
	// {
	// 	x->x_allpasstuningL[i] = (int)(allpasstuningL[i] * sr / 44100);
	// 	x->x_allpasstuningR[i] = (int)(allpasstuningL[i] * sr / 44100);
	// }


static void freeverb_free_numcombs(t_freeverb *x) {
	for(int i=0; i < x->x_numcombs; i++) {
		t_freebytes(x->x_bufcombL+i, x->x_combtuningL[i] * sizeof(t_float));
		t_freebytes(x->x_bufcombR+i, x->x_combtuningR[i] * sizeof(t_float));
	}
	t_freebytes(x->x_combtuningL, 	x->x_numcombs * sizeof(t_int));
	t_freebytes(x->x_combtuningR, 	x->x_numcombs * sizeof(t_int));
	t_freebytes(x->x_filterstoreL, 	x->x_numcombs * sizeof(t_float));
	t_freebytes(x->x_filterstoreR, 	x->x_numcombs * sizeof(t_float));
	t_freebytes(x->x_combidxL, 		x->x_numcombs * sizeof(t_int));
	t_freebytes(x->x_combidxR, 		x->x_numcombs * sizeof(t_int));

}
static void freeverb_free_nallpass(t_freeverb *x) {
	for(int i=0; i < x->x_nallpass; i++) {
		t_freebytes(x->x_bufallpassL+i,
			x->x_allpasstuningL[i] * sizeof(t_float));
		t_freebytes(x->x_bufallpassR+i,
			x->x_allpasstuningR[i] * sizeof(t_float));
	}
	t_freebytes(x->x_allpasstuningL,	x->x_nallpass * sizeof(t_int));
	t_freebytes(x->x_allpasstuningR,	x->x_nallpass * sizeof(t_int));
	t_freebytes(x->x_allpassidxL, 		x->x_nallpass * sizeof(t_int));
	t_freebytes(x->x_allpassidxR, 		x->x_nallpass * sizeof(t_int));
}

static void freeverb_alloc_numcombs(t_freeverb *x) {
	int i, bfsize=0;
	if (x->x_numcombs != x->x_combarrayPoints) {
		freeverb_free_numcombs(x);
		x->x_numcombs = x->x_combarrayPoints;

		x->x_combtuningL  = (t_int *)t_getbytes(x->x_numcombs*sizeof(t_int));
		x->x_combtuningR  = (t_int *)t_getbytes(x->x_numcombs*sizeof(t_int));
		x->x_combidxL	  = (t_int *)t_getbytes(x->x_numcombs*sizeof(t_int));
		x->x_combidxR	  = (t_int *)t_getbytes(x->x_numcombs*sizeof(t_int));
		x->x_filterstoreL=(t_float *)t_getbytes(x->x_numcombs*sizeof(t_float));
		x->x_filterstoreR=(t_float *)t_getbytes(x->x_numcombs*sizeof(t_float));

		// get memory for delay lines
		// initialize comb and allpass inidices arrays
		for(i = 0; i < x->x_numcombs; i++) {
			bfsize	+=	x->x_combtuningL[i];
			x->x_combidxL[i] = 0;
			x->x_combidxR[i] = 0;
		}
		x->x_bufcombL 	  = (t_float*)t_getbytes(bfsize*sizeof(t_float));
		x->x_bufcombR 	  = (t_float*)t_getbytes(bfsize*sizeof(t_float));

	}
}

static void freeverb_alloc_nallpass(t_freeverb *x) {
	int i, bfsize=0;
	if (x->x_nallpass != x->x_allparrayPoints) {
		// we need to free their memory before reallocating
		freeverb_free_nallpass(x);
		x->x_nallpass = x->x_allparrayPoints;

		x->x_allpasstuningL = (t_int *)t_getbytes(x->x_nallpass*sizeof(t_int));
		x->x_allpasstuningR = (t_int *)t_getbytes(x->x_nallpass*sizeof(t_int));
		x->x_allpassidxL 	= (t_int *)t_getbytes(x->x_nallpass*sizeof(t_int));
		x->x_allpassidxR 	= (t_int *)t_getbytes(x->x_nallpass*sizeof(t_int));
		
		// get memory for delay lines
		// initialize comb and allpass inidices arrays
		for(i = 0; i < x->x_nallpass; i++) {
			bfsize += x->x_allpasstuningR[i];
			x->x_allpassidxL[i] = 0;
			x->x_allpassidxR[i] = 0;
		}
		x->x_bufallpassL 	= (t_float*)t_getbytes(bfsize*sizeof(t_float));
		
	}
}

static void freeverb_setarrays(t_freeverb *x, t_symbol *s, int argc, t_atom *argv) {
	t_garray *a;
	switch(argc) {
		case 1:
			// COMB FILTER ARRAY
			if(!(a = (t_garray *)pd_findbyclass(atom_getsymbol(argv), garray_class))) {
			
				post("There is no array %s", argv);
			
				// fall back to default array
				x->x_default_combfil = 1;
				post("%s Using default comb array.", x->x_objsym->s_name);
			
			} else if(!garray_getfloatwords(a, 
				(int *)&x->x_combarrayPoints,&x->x_combvec)) {
			
				pd_error(x, "%s: bad template for %s", 
					x->x_combarrayName->s_name, x->x_objsym->s_name);

				// fall back to default array
				x->x_default_combfil = 1;
				post("%s Using default comb array.", x->x_objsym->s_name);
			
			} else {
				/// we can use this array
				x->x_default_combfil = 0;
				post("Using %s for comb filters", x->x_combarrayName->s_name);
			}
			x->x_default_allpass = 1;
			post("%s Using default all pass array.", x->x_objsym->s_name);
			break;
		case 2:
			// COMB FILTER ARRAY
			if(!(a = (t_garray *)pd_findbyclass(atom_getsymbol(argv), garray_class))) {
			
				post("There is no array %s", atom_getsymbol(argv));
			
				// fall back to default array
				x->x_default_combfil = 1;
				post("%s Using default comb array.", x->x_objsym->s_name);
			
			} else if(!garray_getfloatwords(a, 
				(int *)&x->x_combarrayPoints, &x->x_combvec)) {
			
				pd_error(x, "%s: bad template for %s", 
					x->x_combarrayName->s_name, x->x_objsym->s_name);

				// fall back to default array
				x->x_default_combfil = 1;
				post("%s Using default comb array.", x->x_objsym->s_name);
			
			} else {
				/// we can use this array
				x->x_default_combfil = 0;
				post("Using %s for comb filters", x->x_combarrayName->s_name);
			}
			// ALL PASS FILTER ARRAY
			if(!(a = (t_garray *)pd_findbyclass(atom_getsymbol(argv+1), garray_class))) {
			
				post("There is no array %s", argv+1);
			
				// fall back to default array
				x->x_default_allpass = 1;
				post("%s Using default all pass array.", x->x_objsym->s_name);
			
			} else if(!garray_getfloatwords(a, 
						(int *)&x->x_allparrayPoints, &x->x_allpvec)) {
			
				pd_error(x, "%s: bad template for %s", 
					x->x_allparrayName->s_name, x->x_objsym->s_name);

				// fall back to default array
				x->x_default_allpass = 1;
				post("%s Using default all pass array.", x->x_objsym->s_name);
			
			} else {
				/// we can use this array
				x->x_default_allpass = 0;
				post("Using %s for all pass", x->x_allparrayName->s_name);
			}			
			break;
		default:
			x->x_default_allpass = x->x_default_combfil = 1;
			post("%s Using default arrays.", x->x_objsym->s_name);
			break;
	}
}

static void freeverb_set(t_freeverb *x, t_symbol *s, int argc, t_atom *argv) {
	// pause DSP

	// set array names, sizes, and copy them to local word vectors.
	freeverb_setarrays(x,s,argc,argv);
	
	// if (!x->x_default_combfil) freeverb_alloc_numcombs(x);
	// if (!x->x_default_allpass) freeverb_alloc_nallpass(x);

	// resume DSP
}

/* check for NaN */

typedef union ulf {
    unsigned long   ul;
    float           f;
} ulf;

static inline float fix_denorm_nan_float(float v);

static inline float fix_denorm_nan_float(float v) {
    ulf u;
    u.f = v;
    if ((((u.ul & 0x7f800000) == 0L) && (u.f != 0.f)) || ((u.ul & 0x7f800000) == 0x7f800000))
        /* if the float is denormal or NaN, return 0.0 */
        return 0.0f;
}

/*	End Check for NaN */

/* we need prototypes for Mac for everything */
static void comb_setdamp(t_freeverb *x, t_floatarg val);
static void comb_setfeedback(t_freeverb *x, t_floatarg val);
static inline t_float comb_processL(t_freeverb *x, int fidx, t_float input);
static inline t_float comb_processR(t_freeverb *x, int fidx, t_float input);
static void allpass_setfeedback(t_freeverb *x, t_floatarg val);
static inline t_float allpass_processL(t_freeverb *x, int fidx, t_float input);
static inline t_float allpass_processR(t_freeverb *x, int fidx, t_float input);
t_int *freeverb_perform(t_int *w);
t_int *freeverb_perf8(t_int *w);
static void freeverb_update(t_freeverb *x);
static void freeverb_setroomsize(t_freeverb *x, t_floatarg value);
static float freeverb_getroomsize(t_freeverb *x);
static void freeverb_setdamp(t_freeverb *x, t_floatarg value);
static float freeverb_getdamp(t_freeverb *x);
static void freeverb_setwet(t_freeverb *x, t_floatarg value);
static float freeverb_getwet(t_freeverb *x);
static void freeverb_setdry(t_freeverb *x, t_floatarg value);
static float freeverb_getdry(t_freeverb *x);
static void freeverb_setwidth(t_freeverb *x, t_floatarg value);
static float freeverb_getwidth(t_freeverb *x);
static void freeverb_setmode(t_freeverb *x, t_floatarg value);
static float freeverb_getmode(t_freeverb *x);
static void freeverb_setbypass(t_freeverb *x, t_floatarg value);
static void freeverb_mute(t_freeverb *x);
static float freeverb_getdb(float f);
static void freeverb_print(t_freeverb *x);
static void dsp_add_freeverb(t_freeverb *x, t_sample *in1, t_sample *in2, t_sample *out1, t_sample *out2, int n);
void freeverb_dsp(t_freeverb *x, t_signal **sp);
void freeverb_tilde_setup(void);
static void freeverb_free(t_freeverb *x);
void *freeverb_new(t_symbol *s, int argc, t_atom *argv);


/* -------------------- comb filter stuff ----------------------- */
static void comb_setdamp(t_freeverb *x, t_floatarg f)  {
	x->x_combdamp1 = f; 
	x->x_combdamp2 = 1-f;
}

static void comb_setfeedback(t_freeverb *x, t_floatarg f)  {
	
	x->x_combfeedback = f;
}

// Big to inline - but crucial for speed
static inline t_float comb_processL(t_freeverb *x, int fidx, t_float input) {
	t_float output;
	int bufidx = x->x_combidxL[fidx];

	output = *(x->x_bufcombL + fidx + bufidx);
    fix_denorm_nan_float(output);

    x->x_filterstoreL[fidx] = (output*x->x_combdamp2) + (x->x_filterstoreL[fidx]*x->x_combdamp1);
    fix_denorm_nan_float(x->x_filterstoreL[fidx]);

	*(x->x_bufcombL + fidx + bufidx) = input + (x->x_filterstoreL[fidx]*x->x_combfeedback);
	if(x->x_default_combfil) {
		if(++x->x_combidxL[fidx] >= x->x_combtuningL[fidx])
			x->x_combidxL[fidx]=0;
	} else {
		if(++x->x_combidxL[fidx] >= x->x_combvec[fidx].w_float)
			x->x_combidxL[fidx]=0;

	}
	return output;
}

static inline t_float comb_processR(t_freeverb *x, int fidx, t_float input)
{
	t_float output;
	int bufidx = x->x_combidxR[fidx];

	output = *(x->x_bufcombR + fidx + bufidx);
    fix_denorm_nan_float(output);

	x->x_filterstoreR[fidx] = (output*x->x_combdamp2) + (x->x_filterstoreR[fidx]*x->x_combdamp1);
    fix_denorm_nan_float(x->x_filterstoreR[fidx]);

	*(x->x_bufcombR + fidx + bufidx) = input + (x->x_filterstoreR[fidx]*x->x_combfeedback);

	if(x->x_default_combfil) {
		if(++x->x_combidxR[fidx] >= x->x_combtuningR[fidx])
			x->x_combidxR[fidx]=0;
	} else {
		if(++x->x_combidxR[fidx] >= (x->x_combvec[fidx].w_float)+x->x_spread)
			x->x_combidxR[fidx]=0;

	}

	return output;
}

/* -------------------- allpass filter stuff ----------------------- */
static void allpass_setfeedback(t_freeverb *x, t_floatarg f)  {
	x->x_allpassfeedback = f;
}

// Big to inline - but crucial for speed
static inline t_float allpass_processL(t_freeverb *x, int fidx, t_float input)
{
	t_float output;
	t_float bufout;
	int bufidx = x->x_allpassidxL[fidx];
	
	bufout = (t_float)(*(x->x_bufallpassL+fidx+bufidx));
    fix_denorm_nan_float(bufout);
	
	output = -input + bufout;
	*(x->x_bufallpassL+fidx+bufidx) = input + (bufout*x->x_allpassfeedback);

	if(x->x_default_allpass) {
		if(++x->x_allpassidxL[fidx] >= x->x_allpasstuningL[fidx])
			x->x_allpassidxL[fidx]=0;
	} else {
		if(++x->x_allpassidxL[fidx] >= x->x_allpvec[fidx].w_float)
			x->x_allpassidxL[fidx]=0;

	}
	return output;
}

static inline t_float allpass_processR(t_freeverb *x, int fidx, t_float input)
{
	t_float output;
	t_float bufout;
	int bufidx = x->x_allpassidxR[fidx];
	
	bufout = (t_float)(*(x->x_bufallpassR+fidx+bufidx));
    fix_denorm_nan_float(bufout);
	
	output = -input + bufout;
	*(x->x_bufallpassR+fidx+bufidx) = input + (bufout*x->x_allpassfeedback);

	if(++x->x_allpassidxR[fidx] >= x->x_allpasstuningR[fidx])
		x->x_allpassidxR[fidx] = 0;

	if(x->x_default_allpass) {
		if(++x->x_allpassidxR[fidx] >= x->x_allpasstuningR[fidx])
			x->x_allpassidxR[fidx]=0;
	} else {
		if(++x->x_allpassidxR[fidx] >=(x->x_allpvec[fidx].w_float)+x->x_spread)
			x->x_allpassidxR[fidx]=0;
	}
	return output;
}

/* -------------------- general DSP stuff ----------------------- */
t_int *freeverb_perform(t_int *w)
{
	// assign from parameters
    t_freeverb *x = (t_freeverb *)(w[1]);
    t_float *in1 = (t_float *)(w[2]);
    t_float *in2 = (t_float *)(w[3]);
    t_float *out1 = (t_float *)(w[4]);
    t_float *out2 = (t_float *)(w[5]);
    int n = (int)(w[6]);
	int i;
	t_float outL, outR, inL, inR, input;
    
	if(x->x_bypass)
	{
		// Bypass, so just copy input to output
		while(n--)
		{
			inL = *in1++;// We have to copy first before we can write to output
			inR = *in2++;// since this might be at the same memory position
			*out1++ = inL;
			*out2++ = inR;
		}
	}
	else
	{
    	// DSP loop
		while(n--)
		{
			outL = outR = 0.;
			inL = *in1++;
			inR = *in2++;
			input = (inL + inR) * x->x_gain;

			// Accumulate comb filters in parallel
			for(i=0; i < x->x_numcombs; i++)
			{
				outL += comb_processL(x, i, input);
				outR += comb_processR(x, i, input);
			}

			// Feed through allpasses in series
			for(i=0; i < x->x_nallpass; i++)
			{
				outL = allpass_processL(x, i, outL);
				outR = allpass_processR(x, i, outR);
			}

			// Calculate output REPLACING anything already there
			*out1++ = outL*x->x_wet1 + outR*x->x_wet2 + inL*x->x_dry;
			*out2++ = outR*x->x_wet1 + outL*x->x_wet2 + inR*x->x_dry;
		}
	}
	return(w + 7);
}

// This is a hand unrolled version of the perform routine for
// DSP vector sizes that are multiples of 8
t_int *freeverb_perf8(t_int *w)
{
	// assign from parameters
    t_freeverb *x = (t_freeverb *)(w[1]);
    t_float *in1 = (t_float *)(w[2]);
    t_float *in2 = (t_float *)(w[3]);
    t_float *out1 = (t_float *)(w[4]);
    t_float *out2 = (t_float *)(w[5]);
    int n = (int)(w[6]);
	int i;
	t_float outL[8], outR[8], inL[8], inR[8], input[8];
    
	if(x->x_bypass)
	{
		// Bypass, so just copy input to output
		for(; n; n -= 8, out1 += 8, out2 += 8, in1 += 8, in2 += 8)
		{
			inL[0] 	= in1[0];// We have to copy first before we can write 
			inR[0] 	= in2[0];// since this might be at the same memory position
			out1[0] = inL[0];
			out2[0] = inR[0];
			inL[1] 	= in1[1];
			inR[1] 	= in2[1];
			out1[1] = inL[1];
			out2[1] = inR[1];
			inL[2] 	= in1[2];
			inR[2] 	= in2[2];
			out1[2] = inL[2];
			out2[2] = inR[2];
			inL[3] 	= in1[3];
			inR[3] 	= in2[3];
			out1[3] = inL[3];
			out2[3] = inR[3];
			inL[4] 	= in1[4];
			inR[4] 	= in2[4];
			out1[4] = inL[4];
			out2[4] = inR[4];
			inL[5] 	= in1[5];
			inR[5] 	= in2[5];
			out1[5] = inL[5];
			out2[5] = inR[5];
			inL[6] 	= in1[6];
			inR[6] 	= in2[6];
			out1[6] = inL[6];
			out2[6] = inR[6];
			inL[7] 	= in1[7];
			inR[7] 	= in2[7];
			out1[7] = inL[7];
			out2[7] = inR[7];
		}
	}
	else
	{
    	// DSP loop
		for(; n; n -= 8, out1 += 8, out2 += 8, in1 += 8, in2 += 8)
		{
			outL[0]  = outR [0]= 0.;
			inL[0] 	 = in1[0];
			inR[0] 	 = in2[0];
			input[0] = (inL[0] + inR[0]) * x->x_gain;

			outL[1]  = outR [1]= 0.;
			inL[1]   = in1[1];
			inR[1]   = in2[1];
			input[1] = (inL[1] + inR[1]) * x->x_gain;

			outL[2]  = outR [2]= 0.;
			inL[2]   = in1[2];
			inR[2]   = in2[2];
			input[2] = (inL[2] + inR[2]) * x->x_gain;

			outL[3]  = outR [3]= 0.;
			inL[3]   = in1[3];
			inR[3]   = in2[3];
			input[3] = (inL[3] + inR[3]) * x->x_gain;

			outL[4]  = outR [4]= 0.;
			inL[4]   = in1[4];
			inR[4]   = in2[4];
			input[4] = (inL[4] + inR[4]) * x->x_gain;

			outL[5]  = outR [5]= 0.;
			inL[5]   = in1[5];
			inR[5]   = in2[5];
			input[5] = (inL[5] + inR[5]) * x->x_gain;

			outL[6]  = outR [6]= 0.;
			inL[6]   = in1[6];
			inR[6]   = in2[6];
			input[6] = (inL[6] + inR[6]) * x->x_gain;

			outL[7]  = outR [7]= 0.;
			inL[7]   = in1[7];
			inR[7]   = in2[7];
			input[7] = (inL[7] + inR[7]) * x->x_gain;

			// Accumulate comb filters in parallel
			for(i=0; i < x->x_numcombs; i++)
			{
				outL[0] += comb_processL(x, i, input[0]);
				outR[0] += comb_processR(x, i, input[0]);
				outL[1] += comb_processL(x, i, input[1]);
				outR[1] += comb_processR(x, i, input[1]);
				outL[2] += comb_processL(x, i, input[2]);
				outR[2] += comb_processR(x, i, input[2]);
				outL[3] += comb_processL(x, i, input[3]);
				outR[3] += comb_processR(x, i, input[3]);
				outL[4] += comb_processL(x, i, input[4]);
				outR[4] += comb_processR(x, i, input[4]);
				outL[5] += comb_processL(x, i, input[5]);
				outR[5] += comb_processR(x, i, input[5]);
				outL[6] += comb_processL(x, i, input[6]);
				outR[6] += comb_processR(x, i, input[6]);
				outL[7] += comb_processL(x, i, input[7]);
				outR[7] += comb_processR(x, i, input[7]);
			}

			// Feed through allpasses in series
			for(i=0; i < x->x_nallpass; i++)
			{
				outL[0] = allpass_processL(x, i, outL[0]);
				outR[0] = allpass_processR(x, i, outR[0]);
				outL[1] = allpass_processL(x, i, outL[1]);
				outR[1] = allpass_processR(x, i, outR[1]);
				outL[2] = allpass_processL(x, i, outL[2]);
				outR[2] = allpass_processR(x, i, outR[2]);
				outL[3] = allpass_processL(x, i, outL[3]);
				outR[3] = allpass_processR(x, i, outR[3]);
				outL[4] = allpass_processL(x, i, outL[4]);
				outR[4] = allpass_processR(x, i, outR[4]);
				outL[5] = allpass_processL(x, i, outL[5]);
				outR[5] = allpass_processR(x, i, outR[5]);
				outL[6] = allpass_processL(x, i, outL[6]);
				outR[6] = allpass_processR(x, i, outR[6]);
				outL[7] = allpass_processL(x, i, outL[7]);
				outR[7] = allpass_processR(x, i, outR[7]);
			}

			// Calculate output REPLACING anything already there
			out1[0] = outL[0]*x->x_wet1 + outR[0]*x->x_wet2 + inL[0]*x->x_dry;
			out2[0] = outR[0]*x->x_wet1 + outL[0]*x->x_wet2 + inR[0]*x->x_dry;
			out1[1] = outL[1]*x->x_wet1 + outR[1]*x->x_wet2 + inL[1]*x->x_dry;
			out2[1] = outR[1]*x->x_wet1 + outL[1]*x->x_wet2 + inR[1]*x->x_dry;
			out1[2] = outL[2]*x->x_wet1 + outR[2]*x->x_wet2 + inL[2]*x->x_dry;
			out2[2] = outR[2]*x->x_wet1 + outL[2]*x->x_wet2 + inR[2]*x->x_dry;
			out1[3] = outL[3]*x->x_wet1 + outR[3]*x->x_wet2 + inL[3]*x->x_dry;
			out2[3] = outR[3]*x->x_wet1 + outL[3]*x->x_wet2 + inR[3]*x->x_dry;
			out1[4] = outL[4]*x->x_wet1 + outR[4]*x->x_wet2 + inL[4]*x->x_dry;
			out2[4] = outR[4]*x->x_wet1 + outL[4]*x->x_wet2 + inR[4]*x->x_dry;
			out1[5] = outL[5]*x->x_wet1 + outR[5]*x->x_wet2 + inL[5]*x->x_dry;
			out2[5] = outR[5]*x->x_wet1 + outL[5]*x->x_wet2 + inR[5]*x->x_dry;
			out1[6] = outL[6]*x->x_wet1 + outR[6]*x->x_wet2 + inL[6]*x->x_dry;
			out2[6] = outR[6]*x->x_wet1 + outL[6]*x->x_wet2 + inR[6]*x->x_dry;
			out1[7] = outL[7]*x->x_wet1 + outR[7]*x->x_wet2 + inL[7]*x->x_dry;
			out2[7] = outR[7]*x->x_wet1 + outL[7]*x->x_wet2 + inR[7]*x->x_dry;
			}
	}
	return(w + 7);
}

static void dsp_add_freeverb(t_freeverb *x, t_sample *in1, t_sample *in2, 
							 t_sample *out1, t_sample *out2, int n)
{
	if(n & 7)	// check whether block size is multiple of 8
		dsp_add(freeverb_perform, 6, x, in1, in2, out1, out2, n);
	else
		dsp_add(freeverb_perf8, 6, x, in1, in2, out1, out2, n);
}

void freeverb_dsp(t_freeverb *x, t_signal **sp) {

	dsp_add_freeverb(x, sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[3]->s_vec, sp[0]->s_n);
}

// ----------- general parameter & calculation stuff -----------

	// recalculate internal values after parameter change
static void freeverb_update(t_freeverb *x)
{

	int i;

	x->x_wet1 = x->x_wet*(x->x_width/2 + 0.5);
	x->x_wet2 = x->x_wet*((1-x->x_width)/2);

	if (x->x_mode >= freezemode)
	{
		x->x_roomsize1 = 1.;
		x->x_damp1 = 0.;
		x->x_gain = muted;
	}
	else
	{
		x->x_roomsize1 = x->x_roomsize;
		x->x_damp1 = x->x_damp;
		x->x_gain = (float)fixedgain;
	}

	comb_setfeedback(x, x->x_roomsize1);
	comb_setdamp(x, x->x_damp1);
}

	// the following functions set / get the parameters
static void freeverb_setroomsize(t_freeverb *x, t_floatarg value)
{
	x->x_roomsize = (value*scaleroom) + offsetroom;
	freeverb_update(x);
}

static float freeverb_getroomsize(t_freeverb *x) {
	
	return (x->x_roomsize-offsetroom)/scaleroom;
}

static void freeverb_setdamp(t_freeverb *x, t_floatarg value){
	x->x_damp = value*scaledamp;
	freeverb_update(x);
}

static float freeverb_getdamp(t_freeverb *x){
	
	return x->x_damp/scaledamp;
}

static void freeverb_setwet(t_freeverb *x, t_floatarg value){
	x->x_wet = value*scalewet;
	freeverb_update(x);
}

static float freeverb_getwet(t_freeverb *x) {
	
	return (x->x_wet/scalewet);
}

static void freeverb_setdry(t_freeverb *x, t_floatarg value) {
	
	x->x_dry = value*scaledry;
}

static float freeverb_getdry(t_freeverb *x) {
	
	return (x->x_dry/scaledry);
}

static void freeverb_setwidth(t_freeverb *x, t_floatarg value) {
	x->x_width = value;
	freeverb_update(x);
}

static float freeverb_getwidth(t_freeverb *x) {

	return x->x_width;
}

static void freeverb_setmode(t_freeverb *x, t_floatarg value) {
	x->x_mode = value;
	freeverb_update(x);
}

static float freeverb_getmode(t_freeverb *x) {
	if (x->x_mode >= freezemode)
		return 1;
	else
		return 0;
}

static void freeverb_setbypass(t_freeverb *x, t_floatarg value) {
	x->x_bypass = value;
	if(x->x_bypass)freeverb_mute(x);
}

	// fill delay lines with silence
static void freeverb_mute(t_freeverb *x)
{
	int i;

	if (freeverb_getmode(x) >= freezemode)
		return;

	for (i=0;i<x->x_numcombs;i++) {
		memset(x->x_bufcombL+i, 0x0, x->x_combtuningL[i]*sizeof(t_float));
		memset(x->x_bufcombR+i, 0x0, x->x_combtuningR[i]*sizeof(t_float));
	}
	for (i=0;i<x->x_nallpass;i++) {
		memset(x->x_bufallpassL+i, 0x0, x->x_allpasstuningL[i]*sizeof(t_float));
		memset(x->x_bufallpassR+i, 0x0, x->x_allpasstuningR[i]*sizeof(t_float));
	}
}

	// convert gain factor into dB
static float freeverb_getdb(float f)
{
    if (f <= 0)	// equation does not work for 0...
	{
		return (-96);	// ...so we output max. damping
	}
    else
    {
    	float val = (20./LOGTEN * log(f));
    	return (val);
    }
}

static void freeverb_print(t_freeverb *x)
{
	post("freeverb~:");
	if(x->x_bypass) {
		post("  bypass: on");
	} else post("  bypass: off");
	if(!freeverb_getmode(x)) {
		post("  mode: normal");
	} else post("  mode: freeze");
	post("  roomsize: %g", freeverb_getroomsize(x)*scaleroom+offsetroom);
	post("  damping: %g %%", freeverb_getdamp(x)*100);
	post("  width: %g %%", x->x_width * 100);
	post("  wet level: %g dB", freeverb_getdb(freeverb_getwet(x)*scalewet));
	post("  dry level: %g dB", freeverb_getdb(freeverb_getdry(x)*scaledry));
}

// clean up
// free memory used by delay lines and all other arrays
static void freeverb_free(t_freeverb *x) {
	freeverb_free_numcombs(x);
	freeverb_free_nallpass(x);
}

void *freeverb_new(t_symbol *s, int argc, t_atom *argv) {

	// int sr = (int)sys_getsr();

    t_freeverb *x = (t_freeverb *)pd_new(freeverb_class);
    x->x_objsym = s;
	// add additional signal inlets and signal outlets
	inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
    outlet_new(&x->x_obj, gensym("signal"));
    outlet_new(&x->x_obj, gensym("signal"));

	/*	Original comb filter values */
	x->oCombVals[0]=1116;
	x->oCombVals[1]=1188;
	x->oCombVals[2]=1277;
	x->oCombVals[3]=1356;
	x->oCombVals[4]=1422;
	x->oCombVals[5]=1491;
	x->oCombVals[6]=1557;
	x->oCombVals[7]=1617;

	/*	Original all pass filter values */
	x->oAllPVals[0]=556;
	x->oAllPVals[1]=441;
	x->oAllPVals[2]=341;
	x->oAllPVals[3]=225;

	freeverb_set(x,s,argc,argv);

	// set default values

	x->x_allpassfeedback = 0.5;
	x->x_skip = 1;	// we use every sample
	x->x_spread = stereospread;

	freeverb_setwet(x, initialwet);
	freeverb_setroomsize(x, initialroom);
	freeverb_setdry(x, initialdry);
	freeverb_setdamp(x, initialdamp);
	freeverb_setwidth(x, initialwidth);
	freeverb_setmode(x, initialmode);
	freeverb_setbypass(x, initialbypass);

	// buffers will be full of rubbish - so we MUST mute them
	freeverb_mute(x);

    return (x);
}

void freeverb_tilde_setup(void) {

    freeverb_class = class_new(gensym("freeverb~"),
    	(t_newmethod)freeverb_new,
    	(t_method)freeverb_free,
    	sizeof(t_freeverb), 0,
    	A_GIMME, 0);
	
	CLASS_MAINSIGNALIN(freeverb_class, t_freeverb, x_float);
    
    class_addmethod(freeverb_class, 
    	(t_method)freeverb_dsp, 
    	gensym("dsp"), 
    	A_NULL);
    
    class_addmethod(freeverb_class, 
    	(t_method)freeverb_setroomsize, 
    	gensym("roomsize"), 
    	A_FLOAT, A_NULL);
    
    class_addmethod(freeverb_class,
    	(t_method)freeverb_setdamp,
    	gensym("damping"),
    	A_FLOAT, A_NULL);

    class_addmethod(freeverb_class, 
    	(t_method)freeverb_setwidth, 
    	gensym("width"),
    	A_FLOAT, A_NULL);

	class_addmethod(freeverb_class, 
		(t_method)freeverb_setwet,
		gensym("wet"),
		A_FLOAT, A_NULL);

	class_addmethod(freeverb_class, 
		(t_method)freeverb_setdry,
		gensym("dry"),
		A_FLOAT, A_NULL);

	class_addmethod(freeverb_class, 
		(t_method)freeverb_setmode,
		gensym("freeze"),
		A_FLOAT, A_NULL);

	class_addmethod(freeverb_class, 
		(t_method)freeverb_setbypass,
		gensym("bypass"),
		A_FLOAT, A_NULL);

	class_addmethod(freeverb_class, 
		(t_method)freeverb_mute,
		gensym("clear"),
		A_NULL);

    class_addmethod(freeverb_class, 
    	(t_method)freeverb_print,
    	gensym("print"),
    	A_NULL);

    class_addmethod(freeverb_class, 
    	(t_method)freeverb_set,
    	gensym("set"),
    	A_GIMME, A_NULL);

	logpost(NULL, 4, version);

}