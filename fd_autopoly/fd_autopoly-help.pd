#N canvas 530 51 642 606 12;
#X declare -stdlib Gem;
#X obj 483 184 gemwin;
#X obj 48 122 gemhead;
#X obj 486 230 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X msg 486 250 \; pd dsp \$1 \;;
#X msg 71 279 draw point;
#X msg 503 148 0 \, destroy;
#X obj 471 9 declare -stdlib Gem;
#X text 37 409 CREATION ARGUMENTS:;
#X text 257 19 "fd_autopoly";
#X obj 477 411 s fd_tracktopol;
#X msg 541 362 z \$1;
#X floatatom 541 311 5 0 0 0 - - -, f 5;
#X obj 541 333 / 100;
#X obj 221 244 dac~;
#X floatatom 205 134 5 0 0 0 - - -, f 5;
#X msg 223 167 0;
#X msg 483 107 reset \, FSAA 8 \, create \, 1, f 12;
#X msg 72 304 draw line;
#X obj 48 234 scale 1 1 1 1;
#X obj 48 176 translate -8 0 1 0, f 9;
#X obj 82 151 * -8;
#X obj 205 279 sigmund~ -npeak 10 tracks, f 10;
#X obj 205 199 fd_impulse/fd_impulse-test;
#X text 252 134 <-- shift scroll;
#X msg 477 313 reload;
#X text 253 452 NOTE: your_abs_name needs to output X Y Z coordinates
to be routed just like [sigmund~] \, and it takes a sigmund-dependant
input, f 45;
#X obj 48 345 fd_autopoly curve 10 fd_tracktopol 10 1 1, f 20;
#X text 293 295 <-- -npeaks = 10;
#X text 218 343 <-- N = npeaks = 10;
#X text 38 437 1: polygon||curve \; 2: N = npeaks \; 3: your_abs_name
\; 4: if N<2 \, N \, else arg1 5-6: arg2 \, arg3;
#X text 146 38 Variable point [polygon||curve] creator.;
#X text 49 57 Accepts an abstraction [your_abs_name] to parse [sigmund~]
output., f 66;
#X obj 460 547 fd_tracktopol;
#X text 414 526 see:;
#X obj 460 521 fd_fromsig;
#X connect 1 0 19 0;
#X connect 2 0 3 0;
#X connect 4 0 26 0;
#X connect 5 0 0 0;
#X connect 10 0 9 0;
#X connect 11 0 12 0;
#X connect 12 0 10 0;
#X connect 14 0 22 0;
#X connect 14 0 20 0;
#X connect 14 0 18 1;
#X connect 15 0 22 0;
#X connect 16 0 0 0;
#X connect 17 0 26 0;
#X connect 18 0 26 0;
#X connect 19 0 18 0;
#X connect 20 0 19 1;
#X connect 21 0 26 1;
#X connect 22 0 13 0;
#X connect 22 0 13 1;
#X connect 22 0 21 0;
#X connect 24 0 9 0;
