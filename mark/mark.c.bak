/*
    mark

    outputs a markov sequence

*/

#include "m_pd.h"
#include "math.h"
#include "stdlib.h"
#include <time.h>

#define DEFSTATES 3

static t_class *mark_class;

typedef struct prob {
    t_int       p_prev;
    t_int       p_state;    
} t_prob;

typedef struct mark	{
    t_object	x_ob;
    t_outlet    *x_out1;
    t_int       x_state;
    t_prob      *x_prob;
    t_atom      *x_probs;
    t_int       x_nprob;
    double      x_r;
} t_mark;

static void mark_sprob(t_mark *x) {}

static void mark_set(t_mark *x, t_symbol *s, int argc, t_atom *argv) { 
	double remainder;
    for (int i=0; i<argc; i++) {
        if (argv[i].a_type == A_FLOAT) {
            SETFLOAT(x->x_probs+i, (double) argv[i].a_w.w_float);
            remainder+=argv[i].a_w.w_float;
        }
    }
    if (remainder>=1) {
        post("Warning: sum is greater than 1");
    } else {
        SETFLOAT(x->x_probs+argc,1-remainder);
    }
}

static void mark_reset(t_mark *x) {}

static int mark_index(t_mark *x, double f ) {
    double value = f;
    int index = 0;
    int size = x->x_nprob;
    while ( index < size && atom_getfloat(x->x_probs+index)!= value )
        ++index;
    return ( index == size ? -1 : index );
}

static double mark_get_closest(double a, double b, double f) { 
    if (f - a >= b - f) 
        return b; 
    else
        return a; 
} 

static int mark_find_closest(t_mark *x, double f) { 
    int n = x->x_nprob;
    if (f <= atom_getfloat(x->x_probs)) 
        return 0; 
    if (f >= atom_getfloat(x->x_probs+(n-1))) 
        return n-1; 
    // Doing binary search 
    int i=0, j=n, mid=0; 
    while (i < j) { 
        mid = (i + j) / 2; 
        if (atom_getfloat(x->x_probs+mid) == f) 
            return mid; 
        if (f < atom_getfloat(x->x_probs+mid)) { 
            if (mid > 0 && f > atom_getfloat(x->x_probs+(mid-1))) 
                return mark_index(x,mark_get_closest(
                    atom_getfloat(x->x_probs+(mid-1)),
                    atom_getfloat(x->x_probs+mid), f)); 
            j = mid; 
        } else { 
            if (mid < n - 1 && f < atom_getfloat(x->x_probs+(mid+1))) 
                return mark_index(x,mark_get_closest(
                        atom_getfloat(x->x_probs+mid),
                        atom_getfloat(x->x_probs+(mid+1)), f)); 
            i = mid + 1;  
        }
    }
    return mid; 
} 

static void mark_bang(t_mark *x) {
    t_atom list[2];
    double r = (double) rand() / RAND_MAX;
    int state = mark_find_closest(x,r);
    // SETFLOAT(list,r);
    // SETFLOAT(list+1,state);
    outlet_float(x->x_ob.ob_outlet, state);
    // outlet_list(x->x_ob.ob_outlet, gensym("list"), 2, list);
}

static void mark_float(t_mark *x, t_floatarg f) {}

static void mark_list(t_mark *x, t_symbol *s, int argc, t_atom *argv) {}

void mark_seed(t_mark *x, t_floatarg f) {
    unsigned int seed = (unsigned int) f;
    srand(seed);
}

static void mark_free(t_mark *x) {
    t_freebytes(x->x_probs, (x->x_nprob)*sizeof(t_atom));
}

void *mark_new(t_symbol *s, int argc, t_atom *argv)	{
    int i;
    t_float def_prob=1.0/DEFSTATES;
    t_mark *x = (t_mark *)pd_new(mark_class);
    time_t t;
    srand((unsigned) time(&t));
    if(argc) {
        x->x_probs = (t_atom *)t_getbytes((argc+1)*sizeof(t_atom));
        x->x_nprob = argc+1;
        mark_set(x,s,argc,argv);
    } else {
        x->x_probs = (t_atom *)t_getbytes(DEFSTATES*sizeof(t_atom));
        x->x_nprob = DEFSTATES;
        for (i=0;i<x->x_nprob;i++) SETFLOAT(x->x_probs+i, def_prob);
    }
    x->x_out1 = outlet_new(&x->x_ob, &s_float);
    return (void *)x;
}

void mark_setup(void)	{
    mark_class = class_new(gensym("mark"),
    	(t_newmethod)mark_new, (t_method)mark_free,
    	sizeof(t_mark), 0, 
    	A_GIMME, 0);
    class_addbang(mark_class, mark_bang);
    class_addfloat(mark_class, mark_float);
    class_addlist(mark_class, mark_list);
    class_addmethod(mark_class, 
    	(t_method)mark_set, 
    	gensym("set"), 
    	A_DEFFLOAT, A_DEFFLOAT, 0);
    class_addmethod(mark_class, 
    	(t_method)mark_reset, 
    	gensym("reset"), 0);
    class_addmethod(mark_class, 
        (t_method)mark_seed, 
        gensym("seed"), 
        A_FLOAT, 0);
}